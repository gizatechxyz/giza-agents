import os
import asyncio
import json
import time
from web3 import Web3
from web3.exceptions import TimeExhausted, ContractCustomError
from eth_account import Account
from eth_account.messages import SignableMessage
from eth_typing import Address
from giza_actions.model import GizaModel
import requests
import logging
from giza.frameworks.cairo import verify
from giza_actions.utils import get_endpoint_uri
from giza.client import EndpointsClient
from giza import API_HOST
from pydantic import BaseModel
from dotenv import load_dotenv
from typing import Optional

load_dotenv()

class ProofType(BaseModel):
    address: Address # Who is the signer?
    model_id: int # The model being used for inference
    version_id: int # The version of the model in reference
    endpoint_id: int # The endpoint of the deployed model
    
    class Config:
        protected_namespaces = ()
    
class ProofMessage(BaseModel):
    proofType: ProofType
    
#TODO: Add functions for updating contract, chain id, and endpoint uri
class GizaAgent(GizaModel):
    """
    A blockchain AI agent that helps users put their Actions on-chain. Uses Ape framework and GizaModel to verify a model proof off-chain, sign it with the user's account, and send results to a select EVM chain to execute code.

    Attributes:
        model (GizaModel): The model that this deployer uploads proofs for. This model must have the following fields: id, version, orion_runner_service_url in order to work. This is because all on-chain models require a proof to be generated by Orion Runner.
        inference: The result of the GizaModel inference
        request_id: The request_id of the proof to fetch from the GCP
        proof: The proof from GCP that we will use to verify, sign, and send along with inference data
        

    Methods:
        infer: Runs model inference and retrieves the model output
        get_model_data: retrieves the proof from GCP given the request_id, version_id, endpoint_id, and internal model_id
        generate_calldate: generates calldata for a given smart contract function
        verify: verifies the proof locally
        deploy: verifies the proof, then calls the smart contract with calldata from inference
    """
    #TODO: (GIZ 502) Find a way to abstract away the chain_id to just a string with the chain name
    def __init__(self, contract_address: str, chain_id: int, id: Optional[int] = None, version: Optional[int] = None, **kwargs):
        """Initialize deployer.

        Args:
            contract_address (str): The address of the contract.
            chain_id (int): The ID of the blockchain network.
            id (Optional[int]): Optional ID (default: None).
            version (Optional[int]): Optional version (default: None).
            **kwargs: Additional keyword arguments.
        """
        super().__init__(id=id, version=version, **kwargs)
        contract_sc = Web3.to_checksum_address(contract_address)
        
        #TODO: (GIZ 501) How dow we get the endpoint id from this?
        self.endpoint_uri = get_endpoint_uri(self.model_id, self.version_id)
        
        # self.endpoint_id = 

        self.contract_address = contract_sc
        self.chain_id = chain_id

    def infer(self, input_file=None, input_feed=None, job_size="S"):
        """
        Runs a round of inference on the model and saves the result.
        
        Args:
            input_file: The input file to use for inference
            input_feed: The input feed to use for inference
            job_size: The size of the job to run
        """
        params = {}
        
        if input_file is not None:
            params['input_file'] = input_file
            
        if input_feed is not None:
            params['input_feed'] = input_feed

        params['verifiable'] = True
        params['job_size'] = job_size
        params['output_dtype'] = "Tensor<FP16x16>"
        
        self.inference, self.request_id = self.predict(**params)

        print("Inference saved! ‚úÖ Result: ", self.inference, self.request_id)
        
    def get_model_data(self):
        """
        Get proof data from GCP and save it as a class attribute
        
        Returns:
            proof: The zk proof from GCP
            proof_path: The path to the proof file
        """
        client = EndpointsClient(API_HOST)

        proof_metadata_url = f"https://api.gizatech.xyz/api/v1/models/{self.model_id}/versions/{self.version_id}/endpoints/{self.endpoint_uri}/proofs/{self.request_id}:download"

        time.sleep(3)
        logging.info(f"Fetching proof metadata from {proof_metadata_url}... ‚è≥")

        timeout = time.time() + 8000
        #TODO: GIZ501 Add endpoint ID here too once we have it
        print(f"Request ID: {self.request_id}")
        print(f"Model ID: {self.model_id}")
        print(f"Version ID: {self.version_id}")
        print(f"Framework: {self.framework}")

        while True:
            now = time.time()
            if now > timeout:
                print("Proof retrieval timed out")
                raise TimeoutError("Proof retrieval timed out")
            try:
                #TODO: Verify that we can use endpoint URI here
                proof = client.get_proof(self.model_id, self.version_id, self.endpoint_uri, self.request_id)
                print(f"Proof: {proof.json(exclude_unset=True)}")
                break  # Exit the loop if proof is retrieved successfully
            except requests.exceptions.HTTPError as e:
                print("Proof retrieval failing, sleeping for 5 seconds")
                time.sleep(5)
                
        # Save the proof to a file
        proof_file = "zk.proof"
        content = client.download_proof(self.model_id, self.version_id, self.endpoint_uri, self.request_id)
        with open(proof_file, "wb") as f:
            f.write(content)

        return (content, os.path.abspath(proof_file))
    
    # TODO: (GIZ500) Find a way to match function name with the specific function in the contract regardless of spaces, caps, etc. ALSO, add a method to bind types to the parameters
    async def _generate_calldata(self, function_name: str, parameters: list):
        """
        Generate calldata for calling a smart contract function

        Args:
            contract_address (str): Address of the contract
            chain_id (int): ID of the Ethereum chain
            function_name (str): Name of contract function to call
            parameters (list): Arguments to pass to the function

        Returns:
            str: Hex string of calldata
        """
        web3 = Web3()
        
        try:
            abi = fetch_abi(self.contract_address, self.chain_id)
        except ValueError as e:
            raise ValueError(f"Error fetching contract ABI: {str(e)}") from e
        
        function_abi = next((item for item in abi if 'name' in item and item['name'] == function_name), None)
        
        if function_abi is None:
            raise ValueError(f"Function {function_name} not found in ABI")
        
        contract = web3.eth.contract(address=self.contract_address, abi=abi)
        calldata = contract.encodeABI(function_name, args=parameters)
        return calldata
            
    def sign_proof(self, account: Account, proof: ProofMessage):
        """
        Signs a ProofMessage attesting to the on-chain action result
        
        Args:
            account (Account): The account object used to sign the proof
            proof (ProofMessage): The proof message to sign
        Returns:
            sig: The signature of the proof
            proofMessage: The proof message that was signed
            signable_message: The full message that was signed (with some EIP-191 headers and versioning)
            
        """
        address = account.address
        
        proofType = ProofType(address=address, model_id=self.model_id, version_id=self.version_id, endpoint_id=self.endpoint_id)
        proofMessage = ProofMessage(proofType=proofType)
        
        version = b'\x19'
        header = b''
        
        if isinstance(proof, str):
            body = proof.encode('utf-8')
        else:
            body = proofMessage
        signable_message = SignableMessage(version=version, header=header, body=body)
        sig = account.sign_message(signable_message)
        return (sig, proofMessage, signable_message)
        
    async def verify(self, proof_path):
        """
        Verify proof locally. Must be run *after* infer() and _get_model_data() have been run.
        
        Args:
            proof_path (str): The path to the proof file
        Returns:
            bool: True if proof is valid
        """
        model_id = self.model_id
        version_id = self.version_id
        try:
            result = verify(None, proof=proof_path, model_id=model_id, version_id=version_id)
            if result is None:
                return True
            else:
                return False
        except BaseException as e:
            logging.error("An error occurred when verifying")
            print(e)
            return False
                
    async def transmit(self, account: Account, function_name: str, params, value, signed_proof: SignableMessage, proofMessage: ProofMessage, signedProofMessage, rpc_url: Optional[str], proofsig_enabled: bool = False):
        """
            Transmit: Verify the proof signature (if proofsig_enabled is True), verify the proof, then send the transaction to the contract.

            Args:
                account (Account): The account object used to sign the transaction.
                function_name (str): The name of the contract function to call.
                params: The parameters to pass to the contract function.
                value: The value (in Wei) to send with the transaction (optional).
                signed_proof (SignableMessage): The signed proof message.
                proofMessage (ProofMessage): The proof message object.
                signedProofMessage: The signed proof message.
                rpc_url (Optional[str]): The URL of the RPC endpoint to use (optional).
                proofsig_enabled (bool): Whether to enable proof signature verification or not (default: False).

            Returns:
                A transaction receipt
        """

        web3 = Web3()

        if proofsig_enabled:
            v, r, s = signed_proof.v, signed_proof.r, signed_proof.s
            signed_proof_elements = (v, r, s)
            signer = web3.eth.account.recover_message(signedProofMessage, signed_proof_elements)
            assert signer.lower() == account.address.lower()
            print("Proof signature verified! üî•")

        assert await self.verify(proofMessage.proofType.proof_path)
        print("Proof verified! ‚ö°Ô∏è")

        print("All good! ‚úÖ Sending transaction...")

        try:
            if rpc_url is not None:
                web3 = Web3(Web3.HTTPProvider(rpc_url))
            else:
                alchemy_url = os.getenv("ALCHEMY_URL")
                web3 = Web3(Web3.HTTPProvider(alchemy_url))
            nonce = web3.eth.get_transaction_count(account.address)
            try:
                calldata = await self._generate_calldata(function_name, params)
            except KeyError as e:
                print(f"Error generating calldata: {str(e)}")
                raise
            try:
                transaction = {
                    "to": self.contract_address,
                    "from": account.address,
                    "data": calldata,
                    "nonce": nonce,
                    "gas": web3.eth.estimate_gas({"to": self.contract_address, "data": calldata}),
                    "gasPrice": web3.eth.gas_price,
                    "chainId": self.chain_id
                }
                if value is not None:
                    transaction["value"] = value
            except KeyError as e:
                print(f"Error creating transaction dictionary: {str(e)}")
                raise
            print(f"Transaction: {transaction}")
            try:
                signed_tx = account.sign_transaction(transaction)
            except KeyError as e:
                print(f"Error signing transaction: {str(e)}")
                raise
            print(f"Signed transaction: {signed_tx}")
            try:
                tx_hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)
            except ValueError as e:
                print(f"Error sending transaction: {str(e)}")
                return None
            except Exception as e:
                print(f"Error sending transaction: {str(e)}")
                return None
            try:
                receipt = web3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)
                print("Transaction Completed.")
                return receipt
            except TimeExhausted:
                print("Transaction receipt retrieval timed out.")
                return None

            except asyncio.TimeoutError:
                print("Transaction receipt retrieval timed out after 300 seconds.")
                return None

        except ValueError as e:
            print(f"Error encoding transaction: {e}")
            return None

        except ContractCustomError as e:
            print(f"Custom error occurred: {e}")
            print(f"Error message: {e.args[0]}")
            return None

        except Exception as e:
            print(f"Error transmitting transaction: {str(e)}")
            print(f"Exception type: {type(e)}")
            return None
    
        
        
def get_endpoint_id(model_id, version_id):
    """
    Retrieve the endpoint ID for the model and version.

    Returns:
        int: The ID of the endpoint.
    """
    client = EndpointsClient(API_HOST)
    return client.list(model_id, version_id).root[0].id

def fetch_abi(contract_address, chain_id):
    api_key = os.getenv("ETHERSCAN_API_KEY")
    if not api_key:
        raise ValueError("ETHERSCAN_API_KEY environment variable not set")
    
    if chain_id == 1:
        etherscan_url = "https://api.etherscan.io/api"
    elif chain_id == 11155111:
        etherscan_url = "https://api-sepolia.etherscan.io/api"
    elif chain_id == 5:
        etherscan_url = "https://api-goerli.etherscan.io/api"
    else:
        raise ValueError("Unsupported chain ID")
    
    url = f"{etherscan_url}?module=contract&action=getabi&address={contract_address}&apikey={api_key}"
    
    response = requests.get(url)
    response_json = response.json()
    
    if response_json["status"] == "1":
        abi = response_json["result"]
        return json.loads(abi)
    else:
        raise ValueError(f"Failed to retrieve contract ABI: {response_json['message']}")
